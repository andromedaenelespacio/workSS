
#last updated 27/11/2024
#the following code is for electrical power subsystem modelling 
#it calculates the power generated by the solar paneels, battery discharge and charge cycles, and power distributio to subsystems. 
#it uses mock orbit/epehemeris data for testing purposes.
#last tested and working 
#imports

from datetime import datetime, timedelta
import math
import numpy as np
import matplotlib.pyplot as plt
import orekit
import os 
import sys
from orekit.pyhelpers import setup_orekit_curdir
from org.orekit.utils import IERSConventions
from org.orekit.frames import FramesFactory
from org.orekit.time import AbsoluteDate, TimeScalesFactory
from org.orekit.bodies import OneAxisEllipsoid, CelestialBodyFactory
from org.orekit.forces.gravity.potential import GravityFieldFactory
from org.orekit.forces.gravity import HolmesFeatherstoneAttractionModel
from org.orekit.forces.drag import IsotropicDrag
from org.orekit.propagation.events import EclipseDetector
        

## All orbit, ephemeris, sun, eclipse, attitude, and force data will use Orekit  ##

# code for electrical power subsystem modelling 
#NON SIMULATED PARAMETERS

# This module models the Electrical Power Subsystem (EPS) of the spacecraft.
# It includes components for solar power generation, energy storage in batteries,
# and power distribution to various subsystems.

#constants 
SOLAR_CONSTANT = 1361  # W/m^2, typical value for solar constant in space 


# --- Default/manual input mode selector ---
def get_mode():
    while True:
        mode = input("Select input mode: [D]efault or [M]anual? ").strip().lower()
        if mode in ("d", "default"):
            return "default"
        elif mode in ("m", "manual"):
            return "manual"
        print("Please enter 'D' for default or 'M' for manual.")

mode = get_mode()

#Solar panel class to model the solar panel characteristics and power generation. 

class SolarPanel: # solar panel model to define area, efficiency, degradation rate. 
    def __init__(self, area, efficiency, degradation_rate):
        """
        Initializes a solar panel.
        :parameter area -  Area of the solar panel in square meters (m²).
        :parameter efficiency - Initial efficiency of the solar panel (0-1).
        :parameter degradation_rate -  Annual degradation rate of the panel (0-1). # optional
        """
        self.area = area  # defines the area of the solar panel in m².
        self.efficiency = efficiency  # defines te efficiency of the panel at converting sunlight to electricity.
        self.degradation_rate = degradation_rate  # The rate at which the panel's efficiency decreases annually. (this is optional and might not be known)

    def generate_power(self, irradiance, angle_of_incidence):    #this function is used to calculate power generated by the solar panel
        """
        Calculates the power generated by the solar panel. #different parameters are asked as input (solar irradiance, angle of incidence) which then returns the power generated in watts 
        :param irradiance - Solar irradiance in watts per square meter (W/m²).
        :param angle_of_incidence -  Angle of sunlight incidence in degrees.
        :return: Power generated in watts (W).
        """
        from math import cos, radians     # this imports cosine and radians functions from math module
        # Calculate the angle factor based on the cosine of the angle of incidence.
        angle_factor = max(0, cos(radians(angle_of_incidence)))  # Accounts for the angle of sunlight on the panel.
        # Calculate the power generated based on area, efficiency, and irradiance.
        return self.area * self.efficiency * irradiance * angle_factor


class Battery: #this class models the battery system of the EPS 
    def __init__(self, capacity, efficiency): #this function initializes the battery with capacity and efficiency parameters 
        """
        Initializes a battery.
        :param capacity -  Maximum energy capacity of the battery in watt-hours (Wh). # introduces as an output

        :param efficiency -  Charge/discharge efficiency of the battery (0-1).
        """
        self.capacity = capacity  # The maximum energy the battery can store in Wh.
        self.efficiency = efficiency  # The efficiency of energy transfer during charging and discharging.
        self.charge = capacity  # The current energy stored in the battery, starts fully charged. 

    def charge_battery(self, power, duration):
        """
        Charges the battery.
        :param power -  Input power in watts (W).
        :param duration - Duration of charging in hours (h).
        """
        energy_added = power * duration * self.efficiency
        new_charge = self.charge + energy_added
        if new_charge > self.capacity:
            print(f" Battery overcharge prevented: Attempted {new_charge:.2f} Wh, capped at {self.capacity:.2f} Wh.")
            self.charge = self.capacity
        else:
            self.charge = new_charge
        print(f" Charging: +{energy_added:.2f} Wh | Current charge : {self.charge:.2f} Wh (max {self.capacity:.2f} Wh)")

    def discharge_battery(self, power, duration):
        """
        Discharges the battery.
        :param power: Output power in watts (W).
        :param duration: Duration of discharging in hours (h).
        :return: Energy supplied in watt-hours (Wh).
        """
        energy_needed = power * duration
        # Calculate the energy available in the battery considering efficiency.
        energy_available = self.charge / self.efficiency if self.efficiency > 0 else 0
        energy_supplied = min(energy_needed, energy_available)
        # Prevent battery from going negative
        if energy_supplied < energy_needed: #this indicates the battery is depleted 
            print(f"[Battery depleted: Only {energy_supplied:.2f} Wh supplied, {energy_needed:.2f} Wh needed.") #this indicates how much energy was supplied vs needed
        self.charge -= energy_supplied * self.efficiency #minus energy supplied from battery charge. 
        if self.charge < 0:
            print(f"Battery charge went negative, resetting to 0.")
            self.charge = 0
        print(f"Discharging: -{energy_supplied * self.efficiency:.2f} Wh | Charge Status: {self.charge:.2f} Wh (min 0 Wh)") #this indicates how much energy was discharged on the current energy status 
        return energy_supplied


class PowerDistribution: #this class models the power distribution system of the EPS 
    def __init__(self):
        """
        Initializes the power distribution system.
        """
        self.subsystems = {}  #this initializes an empty dictionary to hold the subsystems and their power demands 

    def add_subsystem(self, name, power_demand): #this function adds a subsystem to the power distribution system 
        """
        Adds a subsystem to the power distribution system.
        :param name -  Name of the subsystem.
        :param power_demand -  Power demand of the subsystem in watts (W).
        """
        # Add the subsystem and its power demand to the dictionary. #this adds the subsystem and its power demand to the dictionary 
        self.subsystems[name] = power_demand 

    def get_total_demand(self): #this function calculates the total power demand of all subsystems
        """
        Calculates the total power demand of all subsystems.
        :return -  Total power demand in watts (W).
        """
        # Sum the power demands of all subsystems.
        return sum(self.subsystems.values())

#this class models the overall electrical power subsystem by integrating solar panel, battery and power distribution components. 
class EPS:
    def __init__(self, solar_panel, battery, distribution): #this function initializes the EPS with solar panel, battery and power distribution system. 
        """
        Initializes the Electrical Power Subsystem (EPS).
        :param solar_panel -  Instance of the SolarPanel class.
        :param battery - Instance of the Battery class.
        :param distribution - Instance of the PowerDistribution class.
        """
        self.solar_panel = solar_panel  # The solar panel used for power generation.
        self.battery = battery  # The battery used for energy storage.
        self.distribution = distribution  # The power distribution system.

    def update(self, irradiance, angle_of_incidence, duration): #this function updates the state of the EPS based on solar irradiance, angle of incidence and duration
        """
        Updates the state of the EPS. 
        :param irradiance -  Solar irradiance in watts per square meter (W/m²). 
        :param angle_of_incidence - Angle of sunlight incidence in degrees. this is the angle at which sunlight hits the solar panel. 
        :param duration - Duration of the simulation step in hours (h).
        """
        # Generate power from the solar panel.
        power_generated = self.solar_panel.generate_power(irradiance, angle_of_incidence) #this calculates the power generated by the solar panel based on irradiance and angle of incidence 

        # Calculate the total power demand from all subsystems.
        total_demand = self.distribution.get_total_demand()

        # If power generated exceeds demand, charge the battery with the excess power.
        if power_generated > total_demand:
            self.battery.charge_battery(power_generated - total_demand, duration)
        else:
            # If power generated is insufficient, discharge the battery to cover the deficit.
            deficit = total_demand - power_generated
            self.battery.discharge_battery(deficit, duration)

    def get_status(self): #this function returns the current status of the EPS.
        """
        Returns the current status of the EPS.
        :return: Dictionary containing the battery charge and total power demand.
        """
        return {
            "battery_charge": self.battery.charge,  # Current energy stored in the battery.
            "total_demand": self.distribution.get_total_demand(),  # Total power demand from all subsystems.
        }



#Vals part 

    ####### Val Import
    from Code_Struct_Sanity_Demo import CSSD

    cssd = CSSD()
    #ephem = cssd.ephem

    #print(ephem.pos[1])
    #######


if __name__ == "__main__": #this block runs when the script is executed directly 
    #not necessary if imported as a module from another script. 

    # Import CSSD and instantiate ephem
    from Code_Struct_Sanity_Demo import CSSD
    cssd = CSSD()
    ephem = cssd.ephem
    mu = cssd.mu
    radius_E = cssd.radius_E
    ts = cssd.ts
    initialDate = cssd.initialDate
    inertialFrame = cssd.inertialFrame
    ITRF = cssd.ITRF
    earth = cssd.earth
    #gm = getattr(cssd, 'gm', None)  # Use getattr in case gm is not defined
    #grav = getattr(cssd, 'grav', None)  # Use getattr in case grav is not defined

    print("ELECTRICAL POWER SUBSYSTEM (EPS) SIMULATION ")
    print()
    # USER INPUT OR DEFAULTS FOR EPS PARAMETERS
    if mode == "default":
        panel_area = 0.5
        panel_efficiency = 0.30
        degradation_rate = 0.005
        battery_capacity = 200000
        battery_efficiency = 0.95
        initial_charge_percent = 100.0
        distribution = PowerDistribution()
        # Example default subsystems
        distribution.add_subsystem("OBDH", 20)
        distribution.add_subsystem("Payload", 30)

        num_subsystems = 2
        print("Default mode selected. Using preset EPS parameters and subsystems.")
    else:
        panel_area = float(input("Enter solar panel area (m²): "))
        panel_efficiency = float(input("Enter solar panel efficiency (0-1, example 0.30 for 30%): "))
        degradation_rate = float(input("Enter annual degradation rate (0-1, example 0.005 for 0.5%): "))
        battery_capacity = float(input("Enter battery capacity (Wh): "))
        battery_efficiency = float(input("Enter battery charge/discharge efficiency (0-1, example 0.95 for 95%): "))
        initial_charge_percent = float(input("Enter initial battery charge (0-100%): "))
        distribution = PowerDistribution()
        num_subsystems = int(input("How many subsystems do you want to add? "))
        for i in range(num_subsystems):
            print(f"Subsystem {i+1}:")
            name = input("  Name: ")
            power = float(input("  Power demand (W): "))
            distribution.add_subsystem(name, power)
    solar_panel = SolarPanel(area=panel_area, efficiency=panel_efficiency, degradation_rate=degradation_rate)
    battery = Battery(capacity=battery_capacity, efficiency=battery_efficiency)
    battery.charge = battery_capacity * (initial_charge_percent / 100)
    eps = EPS(solar_panel, battery, distribution)
    if mode == "default":
        altitude = cssd.alt_a / 1000.0  # convert meters to km
        print(f"Default orbital altitude set to apogee value from CSSD: {altitude} km.")
    else:
        altitude = cssd.alt_a / 1000.0  # convert meters to km
#sunlight/eclipse schedule for the whole simulation based on number of steps and eclipse pattern.
# 
# 
# user input for simulation start date and time  
    local_now = datetime.fromtimestamp(datetime.now().timestamp()) 
    default_start_str = local_now.strftime('%Y-%m-%d %H:%M')
    start_str = input(f"Enter simulation start date and time (YYYY-MM-DD HH:MM) [default: {default_start_str}]: ")
    if start_str.strip() == "":
        start_time = datetime.strptime(default_start_str, '%Y-%m-%d %H:%M')
    else:
        start_time = datetime.strptime(start_str.strip(), '%Y-%m-%d %H:%M')

    # Import all orbit propagation parameters from CSSD
   # drag_force = IsotropicDrag(panel_area, 2.2) #does not affect EPS directly for now but needed for orbit propagation in orekit
   #drag force commented as it is not needed for EPS simulation directly
    # All parameters below are imported from cssd
    a = cssd.a
    e = cssd.e
    i = cssd.i
    omega = cssd.omega
    raan = cssd.raan
    av = cssd.av
    duration_sec = cssd.duration
    stepSize = cssd.stepSize
    # ephem = cssd.ephem  # Already imported above

    # Use modular Sun position retrieval from CSSD
    # Usage: sun_pos = cssd.get_sun_position(date, inertialFrame)

    # Use the Orekit Sun object from CSSD for EclipseDetector
    eclipse_detector = EclipseDetector(cssd.sun_body, float(700000000), earth) # uses CSSD's Orekit Sun object





    battery_charge_history = [] #this list will store the battery charge history over time
    power_generated_history = []
    power_demand_history = []

    #OREKIT BASED SIMULATION LOOP 
    print("\nStepwise EPS simulation using Orekit ephemeris data:")
    print("Step | Date | Angle of Incidence (deg) | Eclipse | Power Generated (W) | Battery (Wh)")
    print(" STARTING SIMULATION")
    print()

    battery_charge_history = [] #this list will store the battery charge history over time
    power_generated_history = []
    power_demand_history = []

    print("\nStepwise EPS simulation using Orekit ephemeris data:")
    print("Step | Date | Angle of Incidence (deg) | Eclipse | Power Generated (W) | Battery (Wh)")
    for idx, (x, y, z) in enumerate(zip(ephem.x_vals, ephem.y_vals, ephem.z_vals)):
        # Gets all relevant info from CSSD
        sc_pos = np.array([x, y, z])  # spacecraft position vector
        date = ephem.dat[idx]         # current date/time
        sun_pos = cssd.get_sun_position(date, cssd.inertialFrame)  # Sun position from CSSD
        panel_normal = sc_pos / np.linalg.norm(sc_pos)
        # Angle of incidence calculation (fully modular)
        sun_vec = sun_pos - sc_pos
        sun_vec_norm = sun_vec / np.linalg.norm(sun_vec)
        cos_theta = np.dot(panel_normal, sun_vec_norm)
        angle = np.degrees(np.arccos(np.clip(cos_theta, -1, 1)))
        # Eclipse detection using CSSD's Orekit Sun body (fully modular)
        in_eclipse = eclipse_detector.g(None, date, sc_pos[0], sc_pos[1], sc_pos[2]) < 0
        irradiance = SOLAR_CONSTANT if not in_eclipse else 0
        power_gen = solar_panel.generate_power(irradiance, angle)
        power_demand = distribution.get_total_demand()
        eps.update(irradiance, angle, cssd.stepSize/3600.0)
        status = eps.get_status()
        battery_charge_history.append(status['battery_charge'])
        power_generated_history.append(power_gen)
        power_demand_history.append(power_demand)
        print(f"{idx+1:4d} | {date} | {angle:8.2f} | {in_eclipse} | {power_gen:10.2f} | {status['battery_charge']:10.2f}")

    print("\nSIMULATION COMPLETE")
    print(f"Final Battery Charge {status['battery_charge']:.3f} Wh") 
    print(f"Total Power Demand: {power_demand:.3f} W") 
    # PLOTTING 
    time_steps = range(len(battery_charge_history)) #
    plt.figure(figsize=(10,6))
    plt.plot(time_steps, battery_charge_history, label='Battery Charge (Wh)')
    plt.plot(time_steps, power_generated_history, label='Solar Power Generated (W)')
    plt.plot(time_steps, power_demand_history, label='Power Demand (W)')
    plt.xlabel('Simulation Step')
    plt.ylabel('Value')
    plt.title('Battery Charge, Power Generated, and Power Demand Over Time (Orekit Orbit)')
    plt.legend()
    plt.grid(True)
    plt.tight_layout()
    plt.show()

    print("\nSIMULATION COMPLETE")
    print(f"Final Battery Charge {status['battery_charge']:.3f} Wh") 
    print(f"Total Power Demand: {power_demand:.3f} W") 
    # PLOTTING 
    time_steps = range(len(battery_charge_history)) #
    plt.figure(figsize=(10,6))
    plt.plot(time_steps, battery_charge_history, label='Battery Charge (Wh)')
    plt.plot(time_steps, power_generated_history, label='Solar Power Generated (W)')
    plt.plot(time_steps, power_demand_history, label='Power Demand (W)')
    plt.xlabel('Simulation Step')
    plt.ylabel('Value')
    plt.title('Battery Charge, Power Generated, and Power Demand Over Time (Orekit Orbit)')
    plt.legend()
    plt.grid(True)
    plt.tight_layout()
    plt.show()


