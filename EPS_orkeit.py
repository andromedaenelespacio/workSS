#ULTIMATE CODE 25/11/2024
#the following code is for electrical power subsystem modelling 
#it calculates the power generated by the solar paneels, battery discharge and charge cycles, and power distributio to subsystems. 
#it uses mock orbit/epehemeris data for testing purposes.
#last tested and working 
#imports
import numpy as np
from datetime import datetime, timedelta

import math
import numpy as np
import matplotlib.pyplot as plt
import orekit
from orekit.pyhelpers import setup_orekit_curdir
from org.orekit.utils import IERSConventions
from org.orekit.frames import FramesFactory
from org.orekit.time import AbsoluteDate, TimeScalesFactory
from org.orekit.bodies import OneAxisEllipsoid, CelestialBodyFactory
from org.orekit.forces.gravity.potential import GravityFieldFactory
from org.orekit.forces.gravity import HolmesFeatherstoneAttractionModel
from org.orekit.forces.drag import IsotropicDrag
from org.orekit.propagation.events import EclipseDetector
        

## All orbit, ephemeris, sun, eclipse, attitude, and force data will use Orekit  ##

# code for electrical power subsystem modelling 
#NON SIMULATED PARAMETERS

# This module models the Electrical Power Subsystem (EPS) of the spacecraft.
# It includes components for solar power generation, energy storage in batteries,
# and power distribution to various subsystems.
SOLAR_CONSTANT = 1361  # W/m^2, typical value for solar constant in space #why is this here?

#ephemeris generator 
'''
import orekit
from orekit.pyhelpers import download_orekit_data_curdir
download_orekit_data_curdir()
import sys
import os
sys.path.append(os.path.join(os.path.dirname(__file__), '..', 'Archive'))
from orbit_propagator_ephemeris_gen import generate_ephemeris
'''

#constants 
SOLAR_CONSTANT = 1361  # W/m^2, typical value for solar constant in space 

#Solar panel class to model the solar panel characteristics and power generation. 

class SolarPanel: # solar panel model to define area, efficiency, degradation rate. 
    def __init__(self, area, efficiency, degradation_rate):
        """
        Initializes a solar panel.
        :parameter area -  Area of the solar panel in square meters (m²).
        :parameter efficiency - Initial efficiency of the solar panel (0-1).
        :parameter degradation_rate -  Annual degradation rate of the panel (0-1). # optional
        """
        self.area = area  # defines the area of the solar panel in m².
        self.efficiency = efficiency  # defines te efficiency of the panel at converting sunlight to electricity.
        self.degradation_rate = degradation_rate  # The rate at which the panel's efficiency decreases annually. (this is optional and might not be known)

    def generate_power(self, irradiance, angle_of_incidence):    #this function is used to calculate power generated by the solar panel
        """
        Calculates the power generated by the solar panel. #different parameters are asked as input (solar irradiance, angle of incidence) which then returns the power generated in watts 
        :param irradiance - Solar irradiance in watts per square meter (W/m²).
        :param angle_of_incidence -  Angle of sunlight incidence in degrees.
        :return: Power generated in watts (W).
        """
        from math import cos, radians     # this imports cosine and radians functions from math module
        # Calculate the angle factor based on the cosine of the angle of incidence.
        angle_factor = max(0, cos(radians(angle_of_incidence)))  # Accounts for the angle of sunlight on the panel.
        # Calculate the power generated based on area, efficiency, and irradiance.
        return self.area * self.efficiency * irradiance * angle_factor


class Battery: #this class models the battery system of the EPS 
    def __init__(self, capacity, efficiency): #this function initializes the battery with capacity and efficiency parameters 
        """
        Initializes a battery.
        :param capacity -  Maximum energy capacity of the battery in watt-hours (Wh). # introduces as an output

        :param efficiency -  Charge/discharge efficiency of the battery (0-1).
        """
        self.capacity = capacity  # The maximum energy the battery can store in Wh.
        self.efficiency = efficiency  # The efficiency of energy transfer during charging and discharging.
        self.charge = capacity  # The current energy stored in the battery, starts fully charged. 

    def charge_battery(self, power, duration):
        """
        Charges the battery.
        :param power -  Input power in watts (W).
        :param duration - Duration of charging in hours (h).
        """
        energy_added = power * duration * self.efficiency
        new_charge = self.charge + energy_added
        if new_charge > self.capacity:
            print(f" Battery overcharge prevented: Attempted {new_charge:.2f} Wh, capped at {self.capacity:.2f} Wh.")
            self.charge = self.capacity
        else:
            self.charge = new_charge
        print(f" Charging: +{energy_added:.2f} Wh | Current charge : {self.charge:.2f} Wh (max {self.capacity:.2f} Wh)")

    def discharge_battery(self, power, duration):
        """
        Discharges the battery.
        :param power: Output power in watts (W).
        :param duration: Duration of discharging in hours (h).
        :return: Energy supplied in watt-hours (Wh).
        """
        energy_needed = power * duration
        # Calculate the energy available in the battery considering efficiency.
        energy_available = self.charge / self.efficiency if self.efficiency > 0 else 0
        energy_supplied = min(energy_needed, energy_available)
        # Prevent battery from going negative
        if energy_supplied < energy_needed: #this indicates the battery is depleted 
            print(f"[Battery depleted: Only {energy_supplied:.2f} Wh supplied, {energy_needed:.2f} Wh needed.") #this indicates how much energy was supplied vs needed
        self.charge -= energy_supplied * self.efficiency #minus energy supplied from battery charge. 
        if self.charge < 0:
            print(f"Battery charge went negative, resetting to 0.")
            self.charge = 0
        print(f"Discharging: -{energy_supplied * self.efficiency:.2f} Wh | Charge Status: {self.charge:.2f} Wh (min 0 Wh)") #this indicates how much energy was discharged on the current energy status 
        return energy_supplied


class PowerDistribution: #this class models the power distribution system of the EPS 
    def __init__(self):
        """
        Initializes the power distribution system.
        """
        self.subsystems = {}  #this initializes an empty dictionary to hold the subsystems and their power demands 

    def add_subsystem(self, name, power_demand): #this function adds a subsystem to the power distribution system 
        """
        Adds a subsystem to the power distribution system.
        :param name -  Name of the subsystem.
        :param power_demand -  Power demand of the subsystem in watts (W).
        """
        # Add the subsystem and its power demand to the dictionary. #this adds the subsystem and its power demand to the dictionary 
        self.subsystems[name] = power_demand 

    def get_total_demand(self): #this function calculates the total power demand of all subsystems
        """
        Calculates the total power demand of all subsystems.
        :return -  Total power demand in watts (W).
        """
        # Sum the power demands of all subsystems.
        return sum(self.subsystems.values())

#this class models the overall electrical power subsystem by integrating solar panel, battery and power distribution components. 
class EPS:
    def __init__(self, solar_panel, battery, distribution): #this function initializes the EPS with solar panel, battery and power distribution system. 
        """
        Initializes the Electrical Power Subsystem (EPS).
        :param solar_panel -  Instance of the SolarPanel class.
        :param battery - Instance of the Battery class.
        :param distribution - Instance of the PowerDistribution class.
        """
        self.solar_panel = solar_panel  # The solar panel used for power generation.
        self.battery = battery  # The battery used for energy storage.
        self.distribution = distribution  # The power distribution system.

    def update(self, irradiance, angle_of_incidence, duration): #this function updates the state of the EPS based on solar irradiance, angle of incidence and duration
        """
        Updates the state of the EPS. 
        :param irradiance -  Solar irradiance in watts per square meter (W/m²). 
        :param angle_of_incidence - Angle of sunlight incidence in degrees. this is the angle at which sunlight hits the solar panel. 
        :param duration - Duration of the simulation step in hours (h).
        """
        # Generate power from the solar panel.
        power_generated = self.solar_panel.generate_power(irradiance, angle_of_incidence) #this calculates the power generated by the solar panel based on irradiance and angle of incidence 

        # Calculate the total power demand from all subsystems.
        total_demand = self.distribution.get_total_demand()

        # If power generated exceeds demand, charge the battery with the excess power.
        if power_generated > total_demand:
            self.battery.charge_battery(power_generated - total_demand, duration)
        else:
            # If power generated is insufficient, discharge the battery to cover the deficit.
            deficit = total_demand - power_generated
            self.battery.discharge_battery(deficit, duration)

    def get_status(self): #this function returns the current status of the EPS.
        """
        Returns the current status of the EPS.
        :return: Dictionary containing the battery charge and total power demand.
        """
        return {
            "battery_charge": self.battery.charge,  # Current energy stored in the battery.
            "total_demand": self.distribution.get_total_demand(),  # Total power demand from all subsystems.
        }


# Test code with manual input
if __name__ == "__main__": #this block runs when the script is executed directly 
    #not necessary if imported as a module from another script. 

    # OREKIT INITIALIZATION AND EPHEMERIS GENERATION 
    orekit.initVM() #initializes orekit virtual machine
    setup_orekit_curdir() #sets up orekit data in current directory 
    mu = 398600.4418 
    radius_E = 6371
    ts = TimeScalesFactory.getUTC() #gets UTC time scale from orekit 
    initialDate = AbsoluteDate(2025, 1, 1, 12, 0, 0.0, ts) #sets initial date for simulation
    inertialFrame = FramesFactory.getICRF() #gets inertial frame from orekit 
    ITRF = FramesFactory.getITRF(IERSConventions.IERS_2010, True) #gets ITRF (International Terrestrial Reference Frame) from orekit 
    earth = OneAxisEllipsoid(radius_E * 1000.0, 0.0, ITRF) #earth model in orekit
    gm = GravityFieldFactory.getNormalizedProvider(8, 8) #gravity field model from orekit needed for force model 
    grav = HolmesFeatherstoneAttractionModel(ITRF, gm) #this creates the gravity force model using the gravity field and ITRF frame 

    print("ELECTRICAL POWER SUBSYSTEM (EPS) SIMULATION ")
    print()
    # USER INPUT FOR EPS PARAMETERS 
    panel_area = float(input("Enter solar panel area (m²): "))
    panel_efficiency = float(input("Enter solar panel efficiency (0-1, example 0.30 for 30%): "))
    degradation_rate = float(input("Enter annual degradation rate (0-1, example 0.005 for 0.5%): "))
    battery_capacity = float(input("Enter battery capacity (Wh): "))
    battery_efficiency = float(input("Enter battery charge/discharge efficiency (0-1, example 0.95 for 95%): "))
    initial_charge_percent = float(input("Enter initial battery charge (0-100%): "))
    distribution = PowerDistribution()
    num_subsystems = int(input("How many subsystems do you want to add? "))
    for i in range(num_subsystems):
        print(f"Subsystem {i+1}:")
        name = input("  Name: ")
        power = float(input("  Power demand (W): "))
        distribution.add_subsystem(name, power)
    solar_panel = SolarPanel(area=panel_area, efficiency=panel_efficiency, degradation_rate=degradation_rate)
    battery = Battery(capacity=battery_capacity, efficiency=battery_efficiency)
    battery.charge = battery_capacity * (initial_charge_percent / 100)
    eps = EPS(solar_panel, battery, distribution)
    print(f"\n Solar Panel: Area={solar_panel.area} m², Efficiency={solar_panel.efficiency*100:.1f}%")
    print(f"Battery: Capacity={battery.capacity} Wh, Initial Charge={battery.charge:.2f} Wh")
    print(f"Subsystems: {distribution.subsystems}")
    print()
    altitude = float(input("Enter orbital altitude (km): "))
    earth_radius = 6371  # km
    mu = 398600.4418  # km^3/s^2
    orbital_radius = earth_radius + altitude
    orbital_period_seconds = 2 * math.pi * math.sqrt(orbital_radius**3 / mu) #formula for orbital period 
    orbital_period_hours = orbital_period_seconds / 3600 #convert seconds to hours
    print(f"Calculated orbital period: {orbital_period_hours:.2f} hours ({orbital_period_seconds/60:.2f} minutes)")
    total_sim_time = float(input("Enter total simulation time (hours): ")) 
    step_minutes = float(input("Enter time step (minutes): "))
    step_hours = step_minutes / 60 #convert minutes to hours 
    #shall I do this one in seconds instead? 
    steps_per_orbit = int(round(orbital_period_hours / step_hours)) #number of steps per orbit
    num_orbits = int(total_sim_time / orbital_period_hours)
    n_steps = int(total_sim_time / step_hours)
    print(f"Simulating {num_orbits} orbits, {steps_per_orbit} steps per orbit, {n_steps} total steps.")
    eclipse_fraction = math.asin(earth_radius / orbital_radius) / math.pi #could be replaced with orekit eclipse detector? #mathematical formula to calculate fraction of orbit in eclipse based on altitude 
    eclipse_time = orbital_period_hours * eclipse_fraction #time spent in eclipse per orbit could be replaced with orekit eclipse detector 
    sunlight_time = orbital_period_hours - eclipse_time #time spent in sunlight per orbit , could be replaced with orekit eclipse detector
    print(f"Per orbit: Sunlight = {sunlight_time:.3f} hours, Eclipse = {eclipse_time:.3f} hours (altitude-dependent)")  
    sunlight_steps = int(round(steps_per_orbit * sunlight_time / orbital_period_hours)) #number of steps in sunlight per orbit 
    eclipse_steps = steps_per_orbit - sunlight_steps #number of steps in eclipse per orbit
    eclipse_pattern = [False]*sunlight_steps + [True]*eclipse_steps #false = sunlight true = eclipse
    eclipse_status = [eclipse_pattern[i % steps_per_orbit] for i in range(n_steps)] #this creates a list indicating eclipse status for each time step in the simulation 
#sunlight/eclipse schedule for the whole simulation based on number of steps and eclipse pattern.
# 
# 
# user input for simulation start date and time  
    local_now = datetime.fromtimestamp(datetime.now().timestamp()) 
    default_start_str = local_now.strftime('%Y-%m-%d %H:%M')
    start_str = input(f"Enter simulation start date and time (YYYY-MM-DD HH:MM) [default: {default_start_str}]: ")
    if start_str.strip() == "":
        start_time = datetime.strptime(default_start_str, '%Y-%m-%d %H:%M')
    else:
        start_time = datetime.strptime(start_str.strip(), '%Y-%m-%d %H:%M')

    drag_force = IsotropicDrag(panel_area, 2.2) #does not affect EPS directly for now but needed for orbit propagation in orekit 
    from orbit_propagator_ephemeris_gen import generate_ephemeris #import the ephemeris generator function from the orbit propagator module 
    a = orbital_radius
    e = 0.001
    i = 98
    omega = 0
    raan = 0
    av = 0.0  # True anomaly at epoch
    duration_sec = total_sim_time * 3600
    stepSize = step_minutes * 60
    ephem = generate_ephemeris(a, e, i, omega, raan, av, inertialFrame, initialDate, mu, radius_E, duration_sec, stepSize)
    sun = CelestialBodyFactory.getSun() #this gets the sun object from orekit 
    eclipse_detector = EclipseDetector(sun, sun.getRadius(), earth) #this creates an eclipse detector using the sun and earth models 

    print(" STARTING SIMULATION")
    print()

    battery_charge_history = [] #this list will store the battery charge history over time
    power_generated_history = []
    power_demand_history = []

    #OREKIT BASED SIMULATION LOOP 

    print("\nStepwise EPS simulation using Orekit ephemeris data:")

    print("Step | Date | Angle of Incidence (deg) | Eclipse | Power Generated (W) | Battery (Wh)")
    for idx, (x, y, z) in enumerate(zip(ephem.x_vals, ephem.y_vals, ephem.z_vals)): #this loops through each time step in the ephemeris data
        sc_pos = np.array([x, y, z]) #spacecraft position vector at current time step 
        date = ephem.dat[idx] #current date/time from ephemeris data 
        sun_pv = sun.getPVCoordinates(date, inertialFrame) #gets sun position/velocity at current date in intertial frame
        sun_pos = np.array([sun_pv.getPosition().getX(), sun_pv.getPosition().getY(), sun_pv.getPosition().getZ()]) #sun position vector at current time step.
        panel_normal = sc_pos / np.linalg.norm(sc_pos) 
        
        #explain this calculation
        # The angle of incidence is calculated as the angle between the solar panel normal vector and the vector pointing from the spacecraft to the sun.
        # This determines how directly sunlight hits the solar panel, affecting power generation.
        
        sun_vec = sun_pos - sc_pos #vector from spcecraft to sun for angle calculation of incidence to solar panel. 
        sun_vec_norm = sun_vec / np.linalg.norm(sun_vec) #normalized sun vector 
        cos_theta = np.dot(panel_normal, sun_vec_norm) #cosine of angle between panel normal and sun vector 
        angle = np.degrees(np.arccos(np.clip(cos_theta, -1, 1))) #angle of incidence in degrees
        in_eclipse = eclipse_detector.g(sun_pv, date, sc_pos[0], sc_pos[1], sc_pos[2]) < 0 #this checks if SC is in eclipse using orekit eclipse detector. 
        irradiance = SOLAR_CONSTANT if not in_eclipse else 0 #if not in eclipse it calculates solar irradiance. 
        power_gen = solar_panel.generate_power(irradiance, angle) #calculates the power generated by the solar panel based on irradiance and angle of incidence. 
        power_demand = distribution.get_total_demand() #calculates the total power demand from all subsystems. 
        eps.update(irradiance, angle, stepSize/3600.0) #updated the EPS state based on current irradiance, angle of incidence and time step duration in hours. 
        status = eps.get_status() #gets the current status of the EPS
        battery_charge_history.append(status['battery_charge']) #stores battery charge history
        power_generated_history.append(power_gen) #stores power generated history
        power_demand_history.append(power_demand) #stores power demand history 
        print(f"{idx+1:4d} | {date} | {angle:8.2f} | {in_eclipse} | {power_gen:10.2f} | {status['battery_charge']:10.2f}") # this print outputs the simulation step data formatted in a table. 
    print("\nSIMULATION COMPLETE")
    print(f"Final Battery Charge {status['battery_charge']:.3f} Wh") 
    print(f"Total Power Demand: {power_demand:.3f} W") 
    # PLOTTING 
    time_steps = range(len(battery_charge_history)) #
    plt.figure(figsize=(10,6))
    plt.plot(time_steps, battery_charge_history, label='Battery Charge (Wh)')
    plt.plot(time_steps, power_generated_history, label='Solar Power Generated (W)')
    plt.plot(time_steps, power_demand_history, label='Power Demand (W)')
    plt.xlabel('Simulation Step')
    plt.ylabel('Value')
    plt.title('Battery Charge, Power Generated, and Power Demand Over Time (Orekit Orbit)')
    plt.legend()
    plt.grid(True)
    plt.tight_layout()
    plt.show()







