#final code to review in sprint

#add that if the entered data is not valid like pressig an enter or something by mistake it should handle that error and ask for the input again without need to restart program. 

#the following code is for electrical power subsystem modelling 
#it calculates the power generated by the solar paneels, battery discharge and charge cycles, and power distributio to subsystems. 
#it uses mock orbit/epehemeris data for testing purposes.
#assumes constant power demand per subsystem per step. 
#assumes all subsystems are always powered 
#ignores losses in power distribution. 

#imports
import numpy as np
from datetime import datetime, timedelta
import math
import numpy as np
import matplotlib.pyplot as plt

# MOCK data Simulated Oreit/ephemeris data for testing purposes
#change this block when integrating with real Orekit ephemeris data 
n_steps = 20  # Number of time steps
# Simulate time steps 
times = [datetime.utcnow() + timedelta(minutes=5*i) for i in range(n_steps)] #utcnow is current time in utc. tmedelta adds time intervals (5 mins here) to create time steps. 
# Simulate positions in a circular orbit (ECI, km)
#positions in a circle of radius 7000 km in the xy plane. 7000 is approx LEO radius. 
#for each step i , it computes the position 
positions = [[7000*np.cos(2*np.pi*i/n_steps), 7000*np.sin(2*np.pi*i/n_steps), 0] for i in range(n_steps)] #formula for circuar motion in 3d space 


# Simulating velocities (km/s)

velocities = [[-7.5*np.sin(2*np.pi*i/n_steps), 7.5*np.cos(2*np.pi*i/n_steps), 0] for i in range(n_steps)] # - bc of direction of motion in circular orbit. because of centripetal force and gravity. 
# # For each step i (out of n_steps samples), it computes a speed of 7.5 units and rotates it by 2π*i/n_steps because of circular motion. 
# the x component is -7.5*sin(θ), the y component is 7.5*cos(θ), and z is 0.
#  So we get evenly spaced tangential velocities for a counter clockwise circle. 
#As θ sweeps 0→2π, sin and cos each range from -1 to +1, 
# so each component ranges from -7.5 to +7.5 while the overall speed stays constant at 7.5.

# Simulate attitudes (identity quaternion)
attitudes = [[1, 0, 0, 0] for _ in range(n_steps)]
#[1, 0, 0, 0] is the identity quaternion, it represents “no rotation.” 
# That list sets every attitude sample to an identity rotation,
#  meaning the spacecraft body frame is assumed aligned with the reference frame for all n_steps.

# Simulate eclipse status: first 5 in sunlight, next 5 in eclipse, repeat
# True = in eclipse, False = in sunlight
eclipse_status = [i % 10 >= 5 for i in range(n_steps)]
#this builds a boolean list marking eclipse vs sinlight in a repeating pattern . % 10 gets remainder when i divided by 10 
#result is every 10 step block has 5 sunlight steps (false) followed by 5 eclipse steps (true).
# end of mock block


# code for electrical power subsystem modelling 
#NON SIMULATED PARAMETERS

# This module models the Electrical Power Subsystem (EPS) of the spacecraft.
# It includes components for solar power generation, energy storage in batteries,
# and power distribution to various subsystems.
SOLAR_CONSTANT = 1361  # W/m^2, typical value for solar constant in space #why is this here?

#ephemeris generator 
#UNCOMMENT WHEN USING OREKIT

#import orekit
#from orekit.pyhelpers import download_orekit_data_curdir
#download_orekit_data_curdir()
#import sys
#import os
#sys.path.append(os.path.join(os.path.dirname(__file__), '..', 'Archive'))
#from orbit_propagator_ephemeris_gen import generate_ephemeris


#class is defined for solar panel,battery and power distribution systems. 
#Solar panel class to model the solar panel characteristics and power generation. 

class SolarPanel: # solar panel model to define area, efficiency, degradation rate. 
    def __init__(self, area, efficiency, degradation_rate):
        """
        Initializes a solar panel.
        :parameter area -  Area of the solar panel in square meters (m²).
        :parameter efficiency - Initial efficiency of the solar panel (0-1).
        :parameter degradation_rate -  Annual degradation rate of the panel (0-1). # optional
        """
        self.area = area  # defines the area of the solar panel in m².
        self.efficiency = efficiency  # defines te efficiency of the panel converting sunlight to electricity.
        self.degradation_rate = degradation_rate  # The rate at which the panel's efficiency decreases annually. (this is optional and might not be known)

    def generate_power(self, irradiance, angle_of_incidence):    #this function is used to calculate power generated by the solar panel
        """
        Calculates the power generated by the solar panel. #different parameters are asked as input (solar irradiance, angle of incidence) which then returns the power generated in watts 
        :param irradiance - Solar irradiance in watts per square meter (W/m²).
        :param angle_of_incidence -  Angle of sunlight incidence in degrees.
        :return: Power generated in watts (W).
        """
        from math import cos, radians     # this imports cosine and radians functions from math module
        # Calculate the angle factor based on the cosine of the angle of incidence.
        angle_factor = max(0, cos(radians(angle_of_incidence)))  # Accounts for the angle of sunlight on the panel.
        # Calculate the power generated based on area, efficiency, and irradiance.
    
        return self.area * self.efficiency * irradiance * angle_factor


class Battery: #this class models the battery system of the EPS 
    def __init__(self, capacity, efficiency): #this function initializes the battery with capacity and efficiency parameters 
        """
        Initializes a battery.
        :param capacity -  Maximum energy capacity of the battery in watt-hours (Wh). # introduces as an output

        :param efficiency -  Charge/discharge efficiency of the battery (0-1).
        """
        self.capacity = capacity  # The maximum energy the battery can store in Wh.
        self.efficiency = efficiency  # The efficiency of energy transfer during charging and discharging.
        self.charge = capacity  # The current energy stored in the battery, starts fully charged. 

    def charge_battery(self, power, duration):
        """
        Charges the battery.
        :param power -  Input power in watts (W).
        :param duration - Duration of charging in hours (h).
        """
        energy_added = power * duration * self.efficiency #calcualte the energy added to the battery considering efficiency. 
        new_charge = self.charge + energy_added #new charge after adding energy. 
        if new_charge > self.capacity: #this is to prevent overcharging of the battery. 
           # print(f"[Battery overcharge prevented: Attempted {new_charge:.2f} Wh, capped at {self.capacity:.2f} Wh.") #attempted charge is capped at nax capacuty 
            self.charge = self.capacity #this sets the charge to max capacity if overcharge 
        else:
            self.charge = new_charge #this updated the charge to new charge if not overcharged. 
        print(f"Charging: +{energy_added:.2f} Wh ------> Charge status  {self.charge:.2f} Wh ") #this prints the energy added and new charge level 



#need to check whether this part is correct and the maths make sense 
    def discharge_battery(self, power, duration): #this function discharged the battery based on power demand and duration. 
        """
        Discharges the battery.
        :param power: Output power in watts (W).
        :param duration: Duration of discharging in hours (h).
        :return: Energy supplied in watt-hours (Wh).
        """
        energy_needed = power * duration
        # Calculate the energy available in the battery considering efficiency.
        energy_available = self.charge / self.efficiency if self.efficiency > 0 else 0 #this calculated the energy available in the batery considering efficiency. 
        #determine the energy that can be supplied
        energy_supplied = min(energy_needed, energy_available) #this determines the energy that can be supplied based on energy needed and available. 
        # Prevent battery from going negative
        if energy_supplied < energy_needed:
            print(f"[Battery depleted: {energy_supplied:.2f} Wh supplied, {energy_needed:.2f} Wh needed.")
        self.charge -= energy_supplied * self.efficiency #this updated the charge after discharging. 
        # substract energy from self.charge

        if self.charge < 0:
    
            # here add that if battery goes to 0 it says not enough power to subsystems and that battery can not handle the load 
            print (f"Battery can not handle the load, not enough power to subsystems")
            self.charge = 0 
        print(f"[Discharging: -{energy_supplied * self.efficiency:.2f} Wh | Charge Status: {self.charge:.2f} Wh (min 0 Wh)") 
        return energy_supplied
    



class PowerDistribution: #this class models the power distribution system of the EPS 
    def __init__(self): #maybe self not needed here since no instance variable are being initialized and it could be done differently. 
        """
        Initializes the power distribution system.
        """
        self.subsystems = {}  #this initializes an empty dictionary to hold the subsystems and their power demands 

    def add_subsystem(self, name, power_demand): #this function adds a subsystem to the power distribution system 
        """
        Adds a subsystem to the power distribution system.
        :param name -  Name of the subsystem.
        :param power_demand -  Power demand of the subsystem in watts (W).
        """
         #this adds the subsystem and its power demand to the dictionary 
        self.subsystems[name] = power_demand 

    def get_total_demand(self): #this function calculates the total power demand of all subsystems
        """
        Calculates the total power demand of all subsystems.
        :return -  Total power demand in watts (W).
        """
        # Sum the power demands of all subsystems.
        return sum(self.subsystems.values())

#this class models the overall electrical power subsystem by integrating solar panel, battery and power distribution components. 
class EPS:
    def __init__(self, solar_panel, battery, distribution): #this function initializes the EPS with solar panel, battery and power distribution system. 
        """
        Initializes the Electrical Power Subsystem (EPS).
        :param solar_panel -  Instance of the SolarPanel class.
        :param battery - Instance of the Battery class.
        :param distribution - Instance of the PowerDistribution class.
        """
        self.solar_panel = solar_panel  # The solar panel used for power generation.
        self.battery = battery  # The battery used for energy storage.
        self.distribution = distribution  # The power distribution system.

    def update(self, irradiance, angle_of_incidence, duration): #this function updates the state of the EPS based on solar irradiance, angle of incidence and duration
        """
        Updates the state of the EPS. 
        :param irradiance -  Solar irradiance in watts per square meter (W/m²). 
        :param angle_of_incidence - Angle of sunlight incidence in degrees. this is the angle at which sunlight hits the solar panel. 
        :param duration - Duration of the simulation step in hours (h).
        """

        # Generate power from the solar panel.
        power_generated = self.solar_panel.generate_power(irradiance, angle_of_incidence) #this calculates the power generated by the solar panel based on irradiance and angle of incidence 
#self here is for the current instance of the EPS class
        # Calculate the total power demand from all subsystems.
        total_demand = self.distribution.get_total_demand()

        # If power generated exceeds demand, charge the battery with the excess power.
        if power_generated > total_demand:
            self.battery.charge_battery(power_generated - total_demand, duration)
        else:
            # If power generated is insufficient, discharge the battery to cover the deficit.
            deficit = total_demand - power_generated
            self.battery.discharge_battery(deficit, duration)

    def get_status(self): #this function returns the current status of the EPS.
        """
        Returns the current status of the EPS.
        :return: Dictionary containing the battery charge and total power demand.
        """
        return {
            "battery_charge": self.battery.charge,  # Current energy stored in the battery.
            "total_demand": self.distribution.get_total_demand(),  # Total power demand from all subsystems.
        }


# Example usage / Test code with manual input
#for testing purposes only , change values when integrating with ephemeris data 

if __name__ == "__main__": #this ensures the test code only runs when this script is executed directly and not when imported from other modules. 


    print("  ELECTRICAL POWER SUBSYSTEM (EPS) SIMULATION")
    print()
    # USER INPUT FOR EPS PARAMETERS 
    #this part gets user input for solar panel, battery and subsystems 
    
    def get_float(prompt, min_val=None, max_val=None):
        while True:
            val = input(prompt) 
            try:
                valf = float(val)
                if min_val is not None and valf < min_val:
                    print(f"Value must be >= {min_val}.")
                    continue
                if max_val is not None and valf > max_val:
                    print(f"Value must be <= {max_val}.")
                    continue
                return valf
            except ValueError:
                print("Invalid input. Please enter a number.")
#this function gets integer input with min and max value checks , to check valid input 

    def get_int(prompt, min_val=None, max_val=None):
        while True:
            val = input(prompt)
            try:
                vali = int(val)
                if min_val is not None and vali < min_val:
                    print(f"Value must be >= {min_val}.")
                    continue
                if max_val is not None and vali > max_val:
                    print(f"Value must be <= {max_val}.")
                    continue
                return vali
            except ValueError:
                print("Invalid input. Please enter an integer.")


    # Solar panel parameters
    panel_area = get_float("Enter solar panel area (m²): ", min_val=0.01)
    panel_efficiency = get_float("Enter solar panel efficiency (0-1, example 0.30 for 30%): ", min_val=0, max_val=1) 
    degradation_rate = get_float("Enter annual degradation rate (0-1, example 0.005 for 0.5%): ", min_val=0, max_val=1)
    # Battery parameters
    battery_capacity = get_float("Enter battery capacity (Wh): ", min_val=0.1)
    battery_efficiency = get_float("Enter battery charge/discharge efficiency (0-1, example 0.95 for 95%): ", min_val=0, max_val=1)
    initial_charge_percent = get_float("Enter initial battery charge (0-100%): ", min_val=0, max_val=100)
    # Subsystems
    distribution = PowerDistribution()
    num_subsystems = get_int("How many subsystems do you want to add? ", min_val=1)
    for i in range(num_subsystems):
        print(f"Subsystem {i+1}:")
        while True:
            name = input("  Name: ").strip()
            if name:
                break
            print("Subsystem name cannot be empty.")
        power = get_float("  Power demand (W): ", min_val=0)
        distribution.add_subsystem(name, power)
    # Create EPS objects
    solar_panel = SolarPanel(area=panel_area, efficiency=panel_efficiency, degradation_rate=degradation_rate)
    battery = Battery(capacity=battery_capacity, efficiency=battery_efficiency)
    battery.charge = battery_capacity * (initial_charge_percent / 100)
    eps = EPS(solar_panel, battery, distribution)
    print(f"\n✓ Solar Panel: Area={solar_panel.area} m², Efficiency={solar_panel.efficiency*100:.1f}%")
    print(f"✓ Battery: Capacity={battery.capacity} Wh, Initial Charge={battery.charge:.2f} Wh")
    print(f"✓ Subsystems: {distribution.subsystems}")
    print()
    # USER INPUT FOR ORBITAL AND SIMULATION PARAMETERS 
    altitude = get_float("Enter orbital altitude (km): ", min_val=0)
    earth_radius = 6371  # km
    mu = 398600.4418  # km^3/s^2
    orbital_radius = earth_radius + altitude
    orbital_period_seconds = 2 * math.pi * math.sqrt(orbital_radius**3 / mu)
    orbital_period_hours = orbital_period_seconds / 3600
    print(f"Calculated orbital period: {orbital_period_hours:.2f} hours ({orbital_period_seconds/60:.2f} minutes)")
    total_sim_time = get_float("Enter total simulation time (hours): ", min_val=0.01)
    step_minutes = get_float("Enter time step (minutes): ", min_val=0.01)
    step_hours = step_minutes / 60
    #should I change to seconds?
    steps_per_orbit = int(round(orbital_period_hours / step_hours)) #this calculated the number of steps per orbit based on orbital period and step duration. 
    num_orbits = int(total_sim_time / orbital_period_hours)
    n_steps = int(total_sim_time / step_hours)
    print(f"Simulating {num_orbits} orbits, {steps_per_orbit} steps per orbit, {n_steps} total steps.")

    #  USER INPUT FOR SUNLIGHT AND ECLIPSE DURATIONS 
    # Calculate sunlight and eclipse durations per orbit (approximate, based on geometry)
    # This is a more physical estimate than a fixed ratio
    eclipse_fraction = math.asin(earth_radius / orbital_radius) / math.pi
    eclipse_time = orbital_period_hours * eclipse_fraction
    sunlight_time = orbital_period_hours - eclipse_time
    print(f"Per orbit: Sunlight = {sunlight_time:.2f} hours, Eclipse = {eclipse_time:.2f} hours (altitude dependent)")
    
    # Update pattern to match these durations
    sunlight_steps = int(round(steps_per_orbit * sunlight_time / orbital_period_hours))
    eclipse_steps = steps_per_orbit - sunlight_steps
    eclipse_pattern = [False]*sunlight_steps + [True]*eclipse_steps #this creates a list marking sunlight as false and eclipse as true based on calculated durations. 
    #but needs to be more specific since it assumes fixed pattern without taking into account real orbit data. 
    eclipse_status = [eclipse_pattern[i % steps_per_orbit] for i in range(n_steps)]
    #  USER INPUT FOR START TIME (LOCAL TIME DEFAULT) 
    import time
    from datetime import datetime
    local_now = datetime.fromtimestamp(time.time())
    default_start_str = local_now.strftime('%Y-%m-%d %H:%M')
    while True:
        start_str = input(f"Enter simulation start date and time (YYYY-MM-DD HH:MM) [default: {default_start_str}]: ")
        if start_str.strip() == "":
            start_time = datetime.strptime(default_start_str, '%Y-%m-%d %H:%M')
            break
        try:
            start_time = datetime.strptime(start_str.strip(), '%Y-%m-%d %H:%M')
            break
        except ValueError:
            print("Invalid date/time format. Please use YYYY-MM-DD HH:MM.")
    # MOCK ORBITAL/EPHEMERIS DATA (ORBIT-BASED) 
    # The following arrays are MOCKED for testing only.

    #here we should replace with the real ephemeris data when integrating with orekit.
    #need to check names match with Val's codes. 
    times = [start_time + timedelta(minutes=step_minutes*i) for i in range(n_steps)]
    # Simple eclipse pattern: 60% sunlight, 40% eclipse per orbit
    #this used in calculating eclipse status based on user input durations 
    sunlight_steps = int(steps_per_orbit * 0.6)
    eclipse_steps = steps_per_orbit - sunlight_steps
    eclipse_pattern = [False]*sunlight_steps + [True]*eclipse_steps
    eclipse_status = [eclipse_pattern[i % steps_per_orbit] for i in range(n_steps)]
    # Mock sun angle: oscillate 0-60 in sunlight, 90 in eclipse
    sun_angles = [(i % steps_per_orbit) * (60/sunlight_steps) if not eclipse_status[i] else 90 for i in range(n_steps)]
    # Mock sun positions (1 AU along x-axis)
    sun_positions = [[1.5e8, 0, 0] for _ in range(n_steps)]
    # Mock drag/SRP forces
    drag_forces = [0.01 + 0.002*i for i in range(n_steps)] 
    srp_forces = [0.005 + 0.001*i for i in range(n_steps)]
    #here explain how each input relates to the math calculations above.
    #MISSING X,Y,Z VALUES FROM VAL 

    
    #  END MOCK ORBITAL/EPHEMERIS DATA 
    solar_irradiance = get_float("Enter solar irradiance (W/m², typical: 1361 for space): ", min_val=0)
    # SIMULATION LOOP 

    battery_charge_history = []
    power_generated_history = []
    power_demand_history = []
    orbit_power_generated = 0
    orbit_power_consumed = 0

    for i in range(n_steps):
        t = times[i]
        in_eclipse = eclipse_status[i]
        sun_angle = sun_angles[i]
        irradiance = solar_irradiance if not in_eclipse else 0
        power_gen = solar_panel.generate_power(irradiance, sun_angle)
        power_demand = distribution.get_total_demand()
        eps.update(irradiance, sun_angle, step_hours)
        status = eps.get_status()
        battery_charge_history.append(status['battery_charge'])
        power_generated_history.append(power_gen)
        power_demand_history.append(power_demand)
        orbit_power_generated += power_gen * step_hours  # Wh
        orbit_power_consumed += power_demand * step_hours  # Wh
        print(f"Step {i+1:3d} | DateTime: {t.strftime('%Y-%m-%d %H:%M')} | Orbit: {(i//steps_per_orbit)+1} | Eclipse: {in_eclipse} | Sun Angle: {sun_angle:.1f}° | Power Gen: {power_gen:.2f} W | Power Demand: {power_demand:.2f} W | Battery: {status['battery_charge']:.2f} Wh")
        # At the end of each orbit, print summary and reset counters

        if (i+1) % steps_per_orbit == 0 or i == n_steps-1:
            orbit_num = (i // steps_per_orbit) + 1
            print(f"--- ORBIT {orbit_num} SUMMARY ---")
            print(f"  Total Power Generated: {orbit_power_generated:.2f} Wh")
            print(f"  Total Power Consumed:  {orbit_power_consumed:.2f} Wh")
            print(f"  Net Power:             {orbit_power_generated - orbit_power_consumed:+.2f} Wh")
            print(f"  Battery at end:        {status['battery_charge']:.2f} Wh\n")
            orbit_power_generated = 0
            orbit_power_consumed = 0
    print("\nSIMULATION COMPLETE")
    #print(f"Final Battery Charge: {status['battery_charge']:.2f} Wh")

    
    # PLOTTING 
    time_steps = range(len(battery_charge_history))
    plt.figure(figsize=(10,6))
    plt.plot(time_steps, battery_charge_history, label='Battery Charge (Wh)')
    plt.plot(time_steps, power_generated_history, label='Solar Power Generated (W)')
    plt.plot(time_steps, power_demand_history, label='Power Demand (W)')
    plt.xlabel('Simulation Step')
    plt.ylabel('Value')
    plt.title('Battery Charge, Power Generated, and Power Demand Over Time (User Input + Mock Orbit)')
    plt.legend()
    plt.grid(True)
    plt.tight_layout()
    plt.show()

    # MOCK FORCE MODEL DATA 
    #  these should be replaced with outputs from Force_Model.py.
    drag_forces = [0.01 + 0.002*i for i in range(n_steps)]  # Newtons, example
    srp_forces = [0.005 + 0.001*i for i in range(n_steps)]  # Newtons, example
    # MOCK SUN POSITION DATA 
#to be replaced with real values from SunPos (celestialbody_config.py). 
#sun_positions = SunPos(dat, inertialFrame).sun_pos
n_steps = 20  # Ensure this matches your simulation steps
sun_positions = [[1.5e8, 0, 0] for _ in range(n_steps)]  
#tomorrow I will try to test it with Val's code. 
